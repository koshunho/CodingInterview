package com.coding;
//56 - I. 数组中数字出现的次数
//一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
//
// 
//
//示例 1：
//
//输入：nums = [4,1,4,6]
//输出：[1,6] 或 [6,1]
//示例 2：
//
//输入：nums = [1,2,10,4,1,4,3,3]
//输出：[2,10] 或 [10,2]
//
public class SingleNumbers_56_1 {
    public int[] singleNumbers(int[] nums) {
        int xorNumber = 0;
        for(int num: nums) xorNumber ^= num;
        int onePosition = xorNumber & (-xorNumber);
        int key1 = 0, key2 = 0;
        for(int num: nums){
            if((num & onePosition) == onePosition){
                key1 ^= num;
            }
            else{
                key2 ^= num;
            }
        }
        return new int [] {key1, key2};
    }
}
//思路：这道题考察位操作。
//位运算：1.性质： a^b(异或)是将a和b的二进制每一位进行异或运算，如果同一位相同则为0，不同为1 （0 ^ 1 = 1， 1^1=0, 0^0=0）
//2.规律：任何数和本身异或则为0，任何数和0异或是本身

//这道题，先将整个数组进行异或，之后得到一个数字，这个数字从二进制的角度来看，一定有位数为1
// （为啥？因为这个数组每个数字都出现了两次的话，整个异或下来，结果应该是0嘛）
//然后这个1又是怎么来的呢？就是那两个值出现一次的数字 异 或 得到的，他们对应的位不一样，肯定有一个数对应位数是0，另一个数字对应位置上出现的数字是1,。因此把这个数组分成2个部分
//①对应的位出现的数是0的数组
//②对应的位出现的数是1的数组
//这两个数组的特点是，数组中只有1个数只出现了1次

//xorNumber：对整个数组求异或，用于求出分组条件
//onePosition：表示最低位1的位置的数。n & （-n） 是求一个二进制数的最低位的1对应的数（意思就是除其所在最低位为1，其他位为0的一个数）
//负数的二进制是正数的补码取反+1
//最后利用onePostion作为划分条件，将数组分成两个数组

//PS。这道题蛮难的，特别是对不熟悉位操作的人来说